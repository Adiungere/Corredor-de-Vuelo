# -*- coding: utf-8 -*-
"""ApendiceA_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14KpwO79_npJrL8yjS3VvFUwIVZ0gBZYQ
"""

!pip install geoplot
!pip install plotly

#from io import SEEK_SET
# esteprograma realiza el Apendice A del CFR 14
# El resultados son las graficas y las coordenadas de la zona de exlusion y corredor de vuelo

import math as m
import math as math
import geoplot as gplt
import numpy as np
import plotly.graph_objects  as go
import pandas as pd 
import fiona


#----------------------------------------------------------------------------------------------------------
#                                                DATOS DE ENTRADA
#----------------------------------------------------------------------------------------------------------
# 20.762896, -87.197700 Cancun
# 24.5, -111.5 Baja californoa
# 18.219890, -87.852486 Merida
# 25.997059, -97.155805 boca chica 
BaseLanzamiento = [24.5*(m.pi)/180, -111.5*m.pi/180]            # Especificar Coordenadas. 
Tipo = 2                                                                # Orbital=1 , SubOrbital=2

Azimut = 230*m.pi/180
Inclinacion = (180/m.pi)*m.acos(m.sin(Azimut)*m.cos(BaseLanzamiento[0])) 
print(Inclinacion)                                          #grado °
PesoCarga = 9000                                           #Especificar Peso de la carga util kg
Apogeo = 200*10**3                                       #Espeficiar apogeo, solo importa para suborbitales, para orbitales no importa el valor
#------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------
ZonaExcl = []
Corredor = BaseLanzamiento
PCirZnExcl = 18
ClasePeso = [[1995.8, 5034.8, 8391.4],[ 1496.8, 3810.1, 6803.8]]  # Datos de del apendice A en Clasiifcacion de lso cohete por su masa de carga util a 185.2 km
ListaDmax = [2222, 2833, 3222, 3963, 2444]                        # Radio de la Zona de exclusion
ListaDoez = [6111, 6426, 7889, 23816, 5889]                        # Rango donde termina la zona de exclusion Small Medium Med-Large Large Sub-Guided

ListaLineasSeg=[[73100, 75500, 77100, 80000, 73900],
              [218300, 219500, 220300, 221800, 218700],
               [3265576, 3265576, 3265576, 3265576, 0]]
Seg1 = 18520
Seg2 = 185200
RangoOrbital = 9260000

#creando función AERtoLLH para usar después
def AERtoLLH(Lat1, Long1, azimut, Rango):
  a_axis=6378.136999995039*10**3
  b_axis=6356.75231420888*10**3
  f=1-b_axis/a_axis
  ecc_sec=(a_axis**2-b_axis**2)**.5/b_axis
  theta=Rango/b_axis
  B1=math.atan2(b_axis*math.sin(Lat1),( a_axis*math.cos(Lat1)))
  g=math.cos(B1)*math.cos(azimut)
  h=math.cos(B1)*math.sin(azimut)
  m=0.5*(1+0.5*(ecc_sec*math.sin(B1))**2)*(1-h**2)
  n=0.5*(1+0.5*(ecc_sec*math.sin(B1))**2)*( (math.sin(B1)**2)*math.cos(theta)+g*math.sin(B1)*math.sin(theta))
  L=h*( -f*theta + 3*(f**2)*n*math.sin(theta) + 0.5*3*(f**2)*m*(theta-math.sin(theta)*math.cos(theta)) )
  M=m*ecc_sec**2                             
  N=n*ecc_sec**2
  A1=N*math.sin(theta)                                    
  A2=(.5*M)*(math.sin(theta)*math.cos(theta)-theta)
  A3=(5/2)*(N**2)*math.sin(theta)*math.cos(theta)
  A4=(M**2/16)*(11*theta-13*math.sin(theta)-8*theta*math.cos(theta)**2+10*math.sin(theta)*math.cos(theta)**3)
  A5=(M*N/2)*(3*math.sin(theta)+2*theta*math.cos(theta)-5*math.sin(theta)*math.cos(theta)**2)
  delta2=theta-A1+A2+A3+A4+A5
  B2_1=math.asin(math.sin(B1)*math.cos(delta2)+g*math.sin(delta2))      
  B2_2=math.acos( ( h**2+(g*math.cos(delta2)-math.sin(B1)*math.sin(delta2))**2)**.5 )
  Lat2=math.atan2(a_axis*math.sin(B2_1),b_axis*math.cos(B2_1))
  Long2=(Long1 + L + math.atan2(math.sin(delta2)*math.sin(azimut),(math.cos(B1)*math.cos(delta2)-math.sin(B1)*math.sin(delta2)*math.cos(azimut))))
  return [Lat2, Long2]

def LLHtoAER(Lat1, Long1, Lat2, Long2):
  if(Lat1 != Lat2 and Long2 != Long1):
    a_axis=6378.136999995039*10**3      # Eje mayor de la elipse de la tierra
    b_axis=6356.75231420888*10**3       # Eje menor de la elipse de la tierra
    f=1-b_axis/a_axis                  # Flatening ratio
    e=(2*f-f**2)**.5                     # Primera Eccentricidad
    pi=3.141592653589793238

    L=Long2-Long1;                      # Diferencia de Longitudes
    B1=math.atan2(b_axis*math.sin(Lat1),(a_axis*math.cos(Lat1)))
    B2=math.atan2(b_axis*math.sin(Lat2),(a_axis*math.cos(Lat2)))
    
    A=math.sin(B1)*math.sin(B2)
    B=math.cos(B1)*math.cos(B2)
    
    delta=math.acos(A+B*math.cos(L))
    n=(a_axis-b_axis)/(a_axis+b_axis)
    B12= Lat2-Lat1 + 2*( A*(n+n**2+n**3) - B*(n-n**2+n**3) )*math.sin(Lat1-Lat2)
    
    #DELTA=math.asin( ( (math.sin(L)*math.cos(B2))**2 + (math.sin(B2-B1) + 2*math.cos(B2)*math.sin(B1)*(math.sin(L/2)**2)))**.5 )
    c=B*math.sin(L)/math.sin(delta)
    m=1-c**2
      
    Range=b_axis*(delta*(1+f+f**2) + A*( (f+f**2)*math.sin(delta) - (f*delta)**2/(2*math.sin(delta)) ) 
       -(m/2)*( (f+f**2)*(delta+math.sin(delta)*math.cos(delta)) - (f*delta)**2/math.tan(delta) )
       -((A*f)**2)*math.sin(delta)*math.cos(delta) 
       +((f*m/4)**2)*( delta + math.sin(delta)*math.cos(delta) - 2*math.sin(delta)*math.cos(delta)**3 - 8*delta**2/math.tan(delta) )
       +( ((A*f)**2)*m/2 )*( math.sin(delta)*math.cos(delta)**2 + delta + delta**2/math.sin(delta) )
       +delta*(f+f**2) - ((A*f**2)/2)*(math.sin(delta) + 2*delta**2/math.sin(delta)) )
    
    LAMBDA= L + c*( 0.25*m*(f**2)*(math.sin(delta)*math.cos(delta) - 5*delta + 4*(delta**2)/math.tan(delta) ))
    Az=(180/pi)*math.atan2( math.cos(B2)*math.sin(LAMBDA),( 2*math.cos(B2)*math.sin(B1)*math.sin(LAMBDA/2)**2 + math.sin(B2-B1)  ))
    alfa21=(180/pi)*math.atan2(-math.cos(B1)*math.sin(LAMBDA),( 2*math.cos(B1)*math.sin(B2)*math.sin(LAMBDA/2)**2 - math.sin(B2-B1)  ))
    Az2=alfa21
  else:
    Az=0
    Range=0
    Az2=0
  vector = [Az, Range, Az2]
  return vector

#Encontrar clase segun el peso para cohetes suborbitales
if Tipo==2:
  Dmax=ListaDmax[4]
  Doez=ListaDoez[4]
  CF=ListaLineasSeg[0][4]
  DE=ListaLineasSeg[1][4]
  R=0.05*Apogeo
  
  if Apogeo <100*10**3:
    D=Apogeo*0.4

  else:
    D=Apogeo*0.7
  
  #defieniendo vectores de la zona de exclusion y utilizando la funcion previa
  FinZonaExcl = []
  FinZonaExcl=AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Doez)
  
  for i in range(PCirZnExcl):
    ZonaExcl.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut+(-270+10*i)*math.pi/180,Dmax))

  for i in range(PCirZnExcl+1,2*PCirZnExcl):
    ZonaExcl.append(AERtoLLH(FinZonaExcl[0], FinZonaExcl[1],Azimut+(-270+10*i)*math.pi/180,Dmax))

  ZonaExcl.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut+(-270)*math.pi/180,Dmax))
  
  #Ubicar punto de impacto y area
  ImpactPoint=[0,0]
  [ImpactPoint[0], ImpactPoint[1]]=AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,D)
  ImpactArea = []

  for i in range(36):
    ImpactArea.append(AERtoLLH(ImpactPoint[0], ImpactPoint[1],Azimut+10*i*(math.pi/180),R))
  
  #definiendo y calculando vectores de las zonas
  ImpactArea.append(AERtoLLH(ImpactPoint[0], ImpactPoint[1],Azimut+10*0*(math.pi/180),R))
  Punto10 = [0,0]
  PuntoD = [[0,0]]

  Corredor = [[ BaseLanzamiento[0],BaseLanzamiento[1] ]]
  [Punto10[0], Punto10[1]]=AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Seg1)

  Corredor.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut-(180-20)*(math.pi/180),Dmax))
  Corredor.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut-(180+20)*(math.pi/180),Dmax))
  Corredor.append(AERtoLLH(Punto10[0], Punto10[1],Azimut+90*(math.pi/180),CF*0.5))

  if D>Seg2:
    i=1
    RangoSuborbital=0
    PuntoD.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Seg2))
    Corredor.append(AERtoLLH(PuntoD[1][0], PuntoD[1][1],Azimut+90*(math.pi/180),.5*DE))

    while RangoSuborbital<D-100000:
      RangoSuborbital=Seg2+i*100000
      PuntoD.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,RangoSuborbital))
      i=i+1
      Corredor.append(AERtoLLH(PuntoD[i][0], PuntoD[i][1],Azimut+90*(math.pi/180),.5*(DE+(RangoSuborbital-Seg2)*(2*R-DE)/(D-Seg2))))

  Corredor.append(AERtoLLH(ImpactPoint[0], ImpactPoint[1],Azimut+90*(math.pi/180),R))
  Corredor.append(AERtoLLH(ImpactPoint[0], ImpactPoint[1],Azimut-90*(math.pi/180),R))

  if D>Seg2:
    while RangoSuborbital>Seg2+100000:
      RangoSuborbital=RangoSuborbital-100000
      Corredor.append(AERtoLLH(PuntoD[i][0], PuntoD[i][1],Azimut-90*(math.pi/180),.5*(DE+(RangoSuborbital-Seg2)*(2*R-DE)/(D-Seg2))))
      i=i-1;
    Corredor.append(AERtoLLH(PuntoD[1][0], PuntoD[1][1],Azimut-90*(math.pi/180),.5*DE))

  Corredor.append(AERtoLLH(Punto10[0], Punto10[1],Azimut-90*(math.pi/180),CF*0.5))
  Corredor.append([Corredor[1][0],Corredor[1][1]])


  #conviertiendo puntos a arrays
  Zonamatriz = np.array(ZonaExcl)
  Corredormatriz = np.array(Corredor)
  Impactmatriz = np.array(ImpactArea)
  
  #creando mapa y primer vector para graficar
  fig = go.Figure(go.Scattermapbox( 
                            
    mode = "markers+lines",
    lon = [BaseLanzamiento[1] * 180 / math.pi],
    lat = [BaseLanzamiento[0] * 180 / math.pi],
    marker = {'size': 5}))

  fig.add_trace(go.Scattermapbox(  
    mode = "markers+lines",
    lon = Corredormatriz[:,1] * 180 / math.pi,
    lat = Corredormatriz[:,0] * 180 / math.pi,
    marker = {'size': 5}))
  fig.add_trace(go.Scattermapbox(  
    mode = "markers+lines",
    lon = Zonamatriz[:,1] * 180 / math.pi,
    lat = Zonamatriz[:,0] * 180 / math.pi,
    marker = {'size': 5}))

  fig.add_trace(go.Scattermapbox(
    mode = "markers+lines",
    lon = Impactmatriz[:,1] * 180 / math.pi,
    lat = Impactmatriz[:,0] * 180 / math.pi,
    marker = {'size': 5}))
    
   
  fig.update_layout(
    margin ={'l':0,'t':0,'b':0,'r':0},
    mapbox = {
        'center': {'lon': 50, 'lat': 70},
        'style': "stamen-terrain",
        'center': {'lon': -40, 'lat': -20},
        'zoom': 0.05})
  fig.show()

  #Zona Impacto
  print("\n")
  ImpactName="ZonaImpacto"+"_"+str(Tipo)+"_"+str((180/m.pi)*BaseLanzamiento[0])+"_" + str((180/m.pi)*BaseLanzamiento[1]) + "_" + str((180/m.pi)*Azimut)+".txt"
  print(ImpactName+"\n")
  ImpactCSV = open(ImpactName, "a")
  for i in range(len(Impactmatriz)):
    ss=str((180/m.pi)*Impactmatriz[i][0])+", "+str((180/m.pi)*Impactmatriz[i][1])
    print(ss)
    ImpactCSV.write(ss+"\n")
  ImpactCSV.close()

#aqui termina el primer tipo y comienza el segundo


#Encontra la clase segun la carga util e inclinacion

if Tipo==1:

  if Inclinacion<=28:
    Incl=0
    if PesoCarga<ClasePeso[Incl][0]:
      Clase=0

    if ClasePeso[Incl][0]<=PesoCarga and PesoCarga<ClasePeso[Incl][1]:
      Clase=1
    
    if ClasePeso[Incl][1]<=PesoCarga and PesoCarga<ClasePeso[Incl][2]:
      Clase=2
    
    if ClasePeso[Incl][2]<=PesoCarga: 
      Clase=3
  else:
    Incl=1
    if PesoCarga<ClasePeso[Incl][0]:
      Clase=0
      
    if ClasePeso[Incl][0]<=PesoCarga and PesoCarga<ClasePeso[Incl][1]:
      Clase=1
  
    if ClasePeso[Incl][1]<=PesoCarga and PesoCarga<ClasePeso[Incl][2]:
      Clase=2
  
    if ClasePeso[Incl][2]<=PesoCarga: 
      Clase=3

  #Calcular parametros de la zona de exclusion y corredor
  Dmax=ListaDmax[Clase]
  Doez=ListaDoez[Clase]
  CF=ListaLineasSeg[0][Clase]
  DE=ListaLineasSeg[1][Clase]
  HI=ListaLineasSeg[2][Clase]
  # Puntos de la zona de exclusion
  FinZonaExcl = []
  FinZonaExcl=AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Doez)

  for i in range(PCirZnExcl):
    ZonaExcl.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut+(-270+10*i)*math.pi/180,Dmax))

  for i in range(PCirZnExcl+1,2*PCirZnExcl):
    ZonaExcl.append(AERtoLLH(FinZonaExcl[0], FinZonaExcl[1],Azimut+(-270+10*i)*math.pi/180,Dmax))

  ZonaExcl.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut+(-270)*math.pi/180,Dmax))

  #Ubicar final del corredor
  Punto10 = []
  Punto100 = []
  Punto5000 = []
  Corredor = [[ BaseLanzamiento[0],BaseLanzamiento[1] ]]


  n=50
  Punto10.append(AERtoLLH(BaseLanzamiento[0],BaseLanzamiento[1],Azimut,Seg1))
  Punto100.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Seg2))
  Corredor.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut-(180-30)*(math.pi/180),Dmax))   
  Corredor.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut-(180+30)*(math.pi/180),Dmax))
  Corredor.append(AERtoLLH(Punto10[0][0], Punto10[0][1],Azimut+90*(math.pi/180),CF*0.5))
  Corredor.append(AERtoLLH(Punto100[0][0], Punto100[0][1],Azimut+90*(math.pi/180),DE*0.5))
  [Az, Range, Az2]=LLHtoAER(Punto10[0][0], Punto10[0][1] ,Punto100[0][0], Punto100[0][1] )
  Punto5000.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Seg2+1*(RangoOrbital-Seg2)/n))
  n=50

  for i in range(1,n+1):
    Punto5000.append(AERtoLLH(BaseLanzamiento[0], BaseLanzamiento[1],Azimut,Seg2+(i+1)*(RangoOrbital-Seg2)/(n+1)))
    [Az, Range, Az2]=LLHtoAER(Punto5000[i-1][0],Punto5000[i-1][1] ,Punto5000[i][0],Punto5000[i][1] )
    #print(Punto5000[i-1][0],Punto5000[i-1][1] ,Punto5000[i][0],Punto5000[i][1])
    #print('[Az, Range, Az2]',[Az, Range, Az2])
    Az=Az*m.pi/180
    Az2=Az2*m.pi/180
    Corredor.append(AERtoLLH(Punto5000[i-1][0],Punto5000[i-1][1], Az+90, 0.5*(DE+i*(HI-DE)/n)))
 
  Corredor.append(AERtoLLH(Punto5000[i][0],Punto5000[i][1], Az+90, 0.5*HI))
  Corredor.append(AERtoLLH(Punto5000[i][0],Punto5000[i][1], Az-90, 0.5*HI))

  for i in range(n,0,-1):
    [Az, Range, Az2]=LLHtoAER(Punto5000[i-1][0],Punto5000[i-1][1] ,Punto5000[i][0],Punto5000[i][1] )
    Az=Az*m.pi/180
    Az2=Az2*m.pi/180
    Corredor.append(AERtoLLH(Punto5000[i][0],Punto5000[i][1], Az-90, 0.5*(DE+i*(HI-DE)/n)))
  
  Corredor.append(AERtoLLH(Punto100[0][0], Punto100[0][1],Azimut-90*(math.pi/180),DE*0.5))
  Corredor.append(AERtoLLH(Punto10[0][0], Punto10[0][1],Azimut-90*(math.pi/180),CF*0.5))
  Corredor.append([Corredor[1][0],Corredor[1][1]])

  #convirtiendo puntor y vectores a matrices(Arrays) para poder graficarlos
  print('ZonaExcl',ZonaExcl)
  Zonamatriz = np.array(ZonaExcl)
  print("Corredormatriz",Zonamatriz)

  Corredormatriz = np.array(Corredor)
  
  Pathmatriz = np.array(Punto5000)
  #print('Pathmatriz', Pathmatriz)
  #graficando 
  fig = go.Figure(go.Scattermapbox( #zona path corredor
                            
    mode = "markers+lines",
    lon = Pathmatriz[:,1] * 180 / math.pi,
    lat = Pathmatriz[:,0] * 180 / math.pi,
    marker = {'size': 5}))

  fig.add_trace(go.Scattermapbox(  
    mode = "markers+lines",
    lon = Corredormatriz[1:,1] * 180 / math.pi,
    lat = Corredormatriz[1:,0] * 180 / math.pi,
    marker = {'size': 5}))
  fig.add_trace(go.Scattermapbox(  
    mode = "markers+lines",
    lon = Zonamatriz[:,1] * 180 / math.pi,
    lat = Zonamatriz[:,0] * 180 / math.pi,
    marker = {'size': 5}))  
   
  fig.update_layout(
    margin ={'l':0,'t':0,'b':0,'r':0},
    mapbox = {
        'center': {'lon': 50, 'lat': 70},
        'style': "stamen-terrain",
        'center': {'lon': -40, 'lat': -20},
        'zoom': 0.05})
  fig.show()



#Zon Exclusion
print("\n")
ZonaName="ZonaExclusion"+"_"+str(Tipo)+"_"+str((180/m.pi)*BaseLanzamiento[0])+"_" + str((180/m.pi)*BaseLanzamiento[1]) + "_" + str((180/m.pi)*Azimut)+".txt"
print(ZonaName+"\n")
ZonaExclCSV = open(ZonaName, "a")
for i in range(len(Zonamatriz)):
  ss=str((180/m.pi)*Zonamatriz[i][0])+", "+str((180/m.pi)*Zonamatriz[i][1])
  print(ss)
  ZonaExclCSV.write(ss+"\n")
ZonaExclCSV.close()

#CorredorCSV
print("\n")

CorredorName="Corredor"+"_"+str(Tipo)+"_"+str((180/m.pi)*BaseLanzamiento[0])+"_" + str((180/m.pi)*BaseLanzamiento[1]) + "_" + str((180/m.pi)*Azimut)+".txt"
print(CorredorName+"\n")
CorredorCSV = open(CorredorName, "a")
for i in range(len(Corredormatriz)):
  ss=str((180/m.pi)*Corredormatriz[i][0])+", "+str((180/m.pi)*Corredormatriz[i][1])
  print(ss)
  CorredorCSV.write(ss+"\n")
CorredorCSV.close()