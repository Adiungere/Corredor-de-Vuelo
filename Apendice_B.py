# -*- coding: utf-8 -*-
"""Apendice B.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H2-SwzzKFdo_Gp1oOtMJ_uOO0dv_KVeE
"""

!pip install geoplot
!pip install plotly

import math
import geoplot as gplt
import numpy as np
import plotly.graph_objects as go
import pandas as pd 
import csv

def ECEFtoLLH(E, F, G):
  a_axis=6378.136999995039*10**3     # Eje mayor de la ellipse de la tierrra
  b_axis=6356.75231420888*10**3      # Eje menos del la Ellipse de la tierra
  f=1-b_axis/a_axis                  # Flatenning ratio, 
  e=(2*f-f**2)**.5                     # Eccentricidad
# Calculas las coordenadas geodetic apartir de las ECEF, estos
  # valores son los que no son exactos y requeriran iteraciones
  longg=math.atan2(F,E)                                       # Primera aproximacion de la longitud
  latg=math.atan2( G*((1-f)**-2),((E**2+F**2)**.5) )              # Primera aproxmacion de la latitud
  hg=(E**2+F**2+G**2)**.5 - a_axis*( (1-e**2) / (    1-( e*math.cos(math.atan(G/((E**2+F**2)**.5))) )**2)   )**.5  #Primera aproximacion de la altura
    

  # Prime radius of curvature. Radio de curvatura longitudinal
  Ng=a_axis/( 1-(e*math.sin(latg))**2 )**.5
  # Meridian radius of curvture. Radio de curvatura latitud
  Mg=a_axis*(1-e**2)*(1-(e*math.sin(latg))**2)**-1.5

  # Imprimimos la primera aproximacion LLH. Esto solo sirve si se alguein
  # tiene interes en conocer el valor, para debuggear el programa
  
  LLH1=np.array([longg,latg,hg])  
  np.transpose(LLH1)
  LLH=LLH1
  # con las coordenadas LLH no exacta calcumos de nuevo las ECEF,
  # estas ECEFg tendran un error con las ECEF, esto nos servira para
  # medir el error de las LLH

  Eg=(Ng+hg)*math.cos(longg)*math.cos(latg)
  Fg=(Ng+hg)*math.sin(longg)*math.cos(latg)
  Gg=(Ng*(1-e**2)+hg)*math.sin(latg)
  
  Error=np.array([Eg,Fg,Gg]) - np.array([E,F,G])
  
  # Haremos esta itereacion hasta que el error sea menor a una cantidad
  while  (Error[0]**2+Error[1]**2+Error[2]**2)**.5>1 :
    # Matriz de transformacion
    dECEFtodENU=[[-math.sin(longg),                    math.cos(longg),                       0],
                [-math.cos(longg)*math.sin(latg), -math.sin(longg)*math.sin(latg), math.cos(latg)],
                [math.cos(longg)*math.cos(latg),  math.sin(longg)*math.cos(latg), math.sin(latg)]]
    dECEFtodENU=np.array(dECEFtodENU)

    # Matriz de transforacion diferencial o Tensor metrico 
    dENUtodLLA=[[1/(math.cos(latg)*(Ng + hg)),     0          ,  0],
                [0                      ,          1/(Mg + hg), 0],
                [0                      ,          0          , 1]]
    dENUtodLLA=np.array(dENUtodLLA)

    dECEFtodLLA=dENUtodLLA@dECEFtodENU
    LLH=LLH-dECEFtodLLA@Error

    longg=LLH[0]
    latg=LLH[1]
    hg=  LLH[2]

    Eg=(Ng+hg)*math.cos(longg)*math.cos(latg)
    Fg=(Ng+hg)*math.sin(longg)*math.cos(latg)
    Gg=(Ng*(1-e**2)+hg)*math.sin(latg)
    Ng=a_axis/( 1-(e*math.sin(latg))**2 )**.5
    Mg=a_axis*(1-e**2)*(1-(e*math.sin(latg))**2)**-1.5
    Error=np.transpose([Eg,Fg,Gg]) - np.transpose([E,F,G])
  
  Long=(longg)
  Lat=(latg)
  High=hg
  return [Lat,Long, High]


#creando función AERtoLLH para usar después
def AERtoLLH(Lat1, Long1, azimut, Rango):
  a_axis=6378.136999995039*10**3
  b_axis=6356.75231420888*10**3
  f=1-b_axis/a_axis
  ecc_sec=(a_axis**2-b_axis**2)**.5/b_axis
  theta=Rango/b_axis
  B1=math.atan2(b_axis*math.sin(Lat1),( a_axis*math.cos(Lat1)))
  g=math.cos(B1)*math.cos(azimut)
  h=math.cos(B1)*math.sin(azimut)
  m=0.5*(1+0.5*(ecc_sec*math.sin(B1))**2)*(1-h**2)
  n=0.5*(1+0.5*(ecc_sec*math.sin(B1))**2)*( (math.sin(B1)**2)*math.cos(theta)+g*math.sin(B1)*math.sin(theta))
  L=h*( -f*theta + 3*(f**2)*n*math.sin(theta) + 0.5*3*(f**2)*m*(theta-math.sin(theta)*math.cos(theta)) )
  M=m*ecc_sec**2                             
  N=n*ecc_sec**2
  A1=N*math.sin(theta)                                    
  A2=(.5*M)*(math.sin(theta)*math.cos(theta)-theta)
  A3=(5/2)*(N**2)*math.sin(theta)*math.cos(theta)
  A4=(M**2/16)*(11*theta-13*math.sin(theta)-8*theta*math.cos(theta)**2+10*math.sin(theta)*math.cos(theta)**3)
  A5=(M*N/2)*(3*math.sin(theta)+2*theta*math.cos(theta)-5*math.sin(theta)*math.cos(theta)**2)
  delta2=theta-A1+A2+A3+A4+A5
  B2_1=math.asin(math.sin(B1)*math.cos(delta2)+g*math.sin(delta2))      
  B2_2=math.acos( ( h**2+(g*math.cos(delta2)-math.sin(B1)*math.sin(delta2))**2)**.5 )
  Lat2=math.atan2(a_axis*math.sin(B2_1),b_axis*math.cos(B2_1))
  Long2=(Long1 + L + math.atan2(math.sin(delta2)*math.sin(azimut),(math.cos(B1)*math.cos(delta2)-math.sin(B1)*math.sin(delta2)*math.cos(azimut))))
  return [Lat2, Long2]

def LLHtoAER(Lat1, Long1, Lat2, Long2):
  if(Lat1 != Lat2 and Long2 != Long1):
    a_axis=6378.136999995039*10**3      # Eje mayor de la elipse de la tierra
    b_axis=6356.75231420888*10**3       # Eje menor de la elipse de la tierra
    f=1-b_axis/a_axis                  # Flatening ratio
    e=(2*f-f**2)**.5                     # Primera Eccentricidad
    pi=3.141592653589793238

    L=Long2-Long1;                      # Diferencia de Longitudes
    B1=math.atan2(b_axis*math.sin(Lat1),(a_axis*math.cos(Lat1)))
    B2=math.atan2(b_axis*math.sin(Lat2),(a_axis*math.cos(Lat2)))
    
    A=math.sin(B1)*math.sin(B2)
    B=math.cos(B1)*math.cos(B2)
    
    delta=math.acos(A+B*math.cos(L))
    n=(a_axis-b_axis)/(a_axis+b_axis)
    B12= Lat2-Lat1 + 2*( A*(n+n**2+n**3) - B*(n-n**2+n**3) )*math.sin(Lat1-Lat2)
    
    #DELTA=math.asin( ( (math.sin(L)*math.cos(B2))**2 + (math.sin(B2-B1) + 2*math.cos(B2)*math.sin(B1)*(math.sin(L/2)**2)))**.5 )
    c=B*math.sin(L)/math.sin(delta)
    m=1-c**2
      
    Range=b_axis*(delta*(1+f+f**2) + A*( (f+f**2)*math.sin(delta) - (f*delta)**2/(2*math.sin(delta)) ) 
       -(m/2)*( (f+f**2)*(delta+math.sin(delta)*math.cos(delta)) - (f*delta)**2/math.tan(delta) )
       -((A*f)**2)*math.sin(delta)*math.cos(delta) 
       +((f*m/4)**2)*( delta + math.sin(delta)*math.cos(delta) - 2*math.sin(delta)*math.cos(delta)**3 - 8*delta**2/math.tan(delta) )
       +( ((A*f)**2)*m/2 )*( math.sin(delta)*math.cos(delta)**2 + delta + delta**2/math.sin(delta) )
       +delta*(f+f**2) - ((A*f**2)/2)*(math.sin(delta) + 2*delta**2/math.sin(delta)) )
    
    LAMBDA= L + c*( 0.25*m*(f**2)*(math.sin(delta)*math.cos(delta) - 5*delta + 4*(delta**2)/math.tan(delta) ))
    Az=(180/pi)*math.atan2( math.cos(B2)*math.sin(LAMBDA),( 2*math.cos(B2)*math.sin(B1)*math.sin(LAMBDA/2)**2 + math.sin(B2-B1)  ))
    alfa21=(180/pi)*math.atan2(-math.cos(B1)*math.sin(LAMBDA),( 2*math.cos(B1)*math.sin(B2)*math.sin(LAMBDA/2)**2 - math.sin(B2-B1)  ))
    Az2=alfa21
  else:
    Az=0
    Range=0
    Az2=0
  vector = [Az, Range, Az2]
  return vector

#importar corredor trayectoria nominal
#Trayectorias Nominales
#"https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/TrayectoriaNominalElectron"
#"https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/YucatanElectron"
#"https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/BajaCaliforniaPolar"
url="https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/BajaCaliforniaPolar"

#Trayeectoria=open("BajaCaliforniaPolar", "r")
#PresionvsAlturaPd=open("PresionvsAltura", "r")
#PresionvsVelocidadPd=open("PresionvsDesviacion", "r")
#PresionvsDesviacionPd=open("PresionvsDesviacion", "r")

trayectoria=pd.read_csv(url)
t = trayectoria["Tiempo"].tolist()
  
VelENU2_E= trayectoria["VelENU2_E"].tolist()
VelENU2_N= trayectoria[" VelENU2_N"].tolist()
VelENU2_U= trayectoria[" VelENU2_U"].tolist()

VelENU=np.array([VelENU2_E, VelENU2_N, VelENU2_U]).T.tolist()

ENU2_E= trayectoria[" ENU2_E"].tolist()
ENU2_N= trayectoria[" ENU2_N"].tolist()
ENU2_U= trayectoria[" ENU2_U"].tolist()

ENU=np.array([ENU2_E, ENU2_N, ENU2_U]).T.tolist()

ECEF2_E= trayectoria[" ECEF2_E"].tolist()
ECEF2_F= trayectoria[" ECEF2_F"].tolist()
ECEF2_G= trayectoria[" ECEF2_G"].tolist()

ECEF=np.array([ECEF2_E, ECEF2_F, ECEF2_G]).T.tolist()

LLH2_Lat= trayectoria[" LLH2_Lat"].tolist()
LLH2_Long= trayectoria[" LLH2_Long"].tolist()
LLH2_High= trayectoria[" LLH2_High"].tolist()

LLH=np.array([LLH2_Lat,LLH2_Long, LLH2_High]).T.tolist()

AER2_Az= trayectoria[" AER2_Az"].tolist()
AER2_El= trayectoria[" AER2_El"].tolist()
AER2_R= trayectoria[" AER2_R"].tolist()

AER=np.array([AER2_Az, AER2_El, AER2_R]).T.tolist()
pi=3.141592
# Datos meteorologicos
urlPresionvsAltura="https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/PresionvsAltura.csv"
urlDesviacion="https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/PresionvsDesviacion.csv"
urlVelocidad="https://raw.githubusercontent.com/OmarACordova/Corredor-de-Vuelo/main/PresionvsVelocidad.csv"

PresionvsAlturaPd=pd.read_csv(urlPresionvsAltura)
PresionvsVelocidadPd=pd.read_csv(urlVelocidad)
PresionvsDesviacionPd=pd.read_csv(urlDesviacion)

keyPvA=PresionvsAlturaPd.keys()
VecPvA=[PresionvsAlturaPd[keyPvA[0]].tolist()]
for i in range(1,len(keyPvA)):
  VecPvA.append(PresionvsAlturaPd[keyPvA[i]].tolist())
PresionvsAltura=np.array(VecPvA).T.tolist()

keyPvV=PresionvsVelocidadPd.keys()
VecPvV=[PresionvsVelocidadPd[keyPvV[0]].tolist()]
for i in range(1,len(keyPvV)):
  VecPvV.append(PresionvsVelocidadPd[keyPvA[i]].tolist())
PresionvsVelocidad=np.array(VecPvV).T.tolist()

keyDes=PresionvsDesviacionPd.keys()
VecDes=[PresionvsDesviacionPd[keyDes[0]].tolist()]
for i in range(1,len(keyPvV)):
  VecDes.append(PresionvsDesviacionPd[keyDes[i]].tolist())
PresionvsDesviacion=np.array(VecDes).T.tolist()

BaseLanzamiento=LLH[0]  #dejar modificación para el final
print(BaseLanzamiento)
[Azt, Range, Azt2]=LLHtoAER(BaseLanzamiento[0]*pi/180, BaseLanzamiento[1]*pi/180, LLH[100][0]*pi/180, LLH[100][1]*pi/180)
Azt=Azt*pi/180
Azt2=Azt2*pi/180

PresionSec=[1000,850,700,500,400,300,250,200,150,100,70,50,30,10]
CoeffBallistic=14.6
Gravity=9.8
Mu=6.674*10**-11
EarthMass=5.972*10**24
pi=3.141592

D=[0]
Azt=[0]
Azt2=[0]
Az=[0]
Az2=[0]
ZonaExclDer=[[0,0]]
ZonaExclIzq=[[0,0]]

# Difinir zona de Exclusion
i=1
IntRango=1
while LLH[i][2]<16000:

  IntRango=0
  # Ubicarse en el internavlo de rang0
  while PresionvsAltura[IntRango][0]<=AER[i][2] :
    IntRango=IntRango+1
  
  #Ubicarse en el internvalo del altura 
  IntAlt=1
  while PresionvsAltura[IntRango][IntAlt]<=LLH[i][2]:
    IntAlt=IntAlt+1
  
  D.append(0)
  Azt.append(0)
  Azt2.append(0)
  
  #Calcualr radio de Dispersion
  for IntAlturas in range(IntAlt,1,-1):
    Rho=1.3*math.exp(-LLH[i][2]/7000)          # Densidad Standard de la atmosfera
    VelCaida=(2*CoeffBallistic*Gravity/Rho)**.5

    if IntAlturas==IntAlt:
      dt=(LLH[i][2]-PresionvsAltura[IntRango][IntAlturas-1])/VelCaida
    else:
      dt=(PresionvsAltura[IntRango][IntAlturas]-PresionvsAltura[IntRango][IntAlturas-1])/VelCaida
    
    D[i]=D[i]+dt*PresionvsVelocidad[IntRango][IntAlturas]  
  
  if i>10:
    [Azt[i], Range, Azt2[i]]=LLHtoAER(BaseLanzamiento[0]*pi/180, BaseLanzamiento[1]*pi/180, LLH[i][0]*pi/180, LLH[i][1]*pi/180)
    Az.append(Azt[i]*pi/180)
    Az2.append(Azt2[i]*pi/180)
  else:
    Az.append(Azt[i-1])
    Az2.append(Azt2[i-1])
  

  ZonaExclDer.append(AERtoLLH(LLH[i][0]*pi/180, LLH[i][1]*pi/180, Az2[i]+pi/2, D[i]))
  ZonaExclIzq.append(AERtoLLH(LLH[i][0]*pi/180, LLH[i][1]*pi/180, Az2[i]-pi/2, D[i]))
  i=i+1
   
print(ZonaExclDer)
print(ZonaExclIzq)

# Definir Corredor de vuelo
# ECEF to ENU
ENUtoECEF=[[-math.sin(BaseLanzamiento[1]*pi/180) , -math.cos(BaseLanzamiento[1]*pi/180)*math.sin(BaseLanzamiento[0]*pi/180) , math.cos(BaseLanzamiento[1]*pi/180)*math.cos(BaseLanzamiento[0]*pi/180)],
           [ math.cos(BaseLanzamiento[1]*pi/180) , -math.sin(BaseLanzamiento[1]*pi/180)*math.sin(BaseLanzamiento[0]*pi/180) , math.sin(BaseLanzamiento[1]*pi/180)*math.cos(BaseLanzamiento[0]*pi/180)],
            [                            0        ,                          math.cos(BaseLanzamiento[0]*pi/180)                 ,               math.sin(BaseLanzamiento[0]*pi/180) ]]
ENUtoECEF=np.array(ENUtoECEF)

ECEFtoENU=[[                               -math.sin(BaseLanzamiento[1]*pi/180)       ,                          math.cos(BaseLanzamiento[1]*pi/180)            ,                  0                 ],
           [-math.cos(BaseLanzamiento[1]*pi/180)*math.sin(BaseLanzamiento[0]*pi/180) , -math.sin(BaseLanzamiento[1]*pi/180)*math.sin(BaseLanzamiento[0]*pi/180) , math.cos(BaseLanzamiento[0]*pi/180)],
           [math.cos(BaseLanzamiento[1]*pi/180)*math.cos(BaseLanzamiento[0]*pi/180) , math.sin(BaseLanzamiento[1]*pi/180)*math.cos(BaseLanzamiento[0]*pi/180) , math.sin(BaseLanzamiento[0]*pi/180) ]]
ECEFtoENU=np.array(ECEFtoENU)
dt=1
i_init=i
jIP=[0]
IP_Cen=[0]
IP_Izq=[0]
IP_Der=[0]


# Calcular a dinamica de vuelo de la primera etapa miestras se encuentre
    # en el aire, por encima del suelo
Rango=0 
ECEF_Cen=[np.array([0,0,0])]
ECEF_Der=[np.array([0,0,0])]
ECEF_Izq=[np.array([0,0,0])]

Vel_ECEF=[np.array([0,0,0])]

Vel_ECEF_Cen=[np.array([0,0,0])]
Vel_ECEF_Der=[np.array([0,0,0])]
Vel_ECEF_Izq=[np.array([0,0,0])]

Acc_ECEF_Cen=[np.array([0,0,0])]
Acc_ECEF_Der=[np.array([0,0,0])]
Acc_ECEF_Izq=[np.array([0,0,0])]

Desv_Cen=[[np.array([0,0,0])]]
Desv_Der=[[np.array([0,0,0])]]
Desv_Izq=[[np.array([0,0,0])]]

ENU_Cen=[np.array([0,0,0])]
ENU_Der=[np.array([0,0,0])]
ENU_Izq=[np.array([0,0,0])]

AER_Cen=[np.array([0,0,0])]
AER_Der=[np.array([0,0,0])]
AER_Izq=[np.array([0,0,0])]

Gravity_Cen=[np.array([0,0,0])]
Gravity_Der=[np.array([0,0,0])]
Gravity_Izq=[np.array([0,0,0])]

ilocmax=0
while Rango<9260000:
  j=0

  print("i=",i)
  iloc=i-i_init

  ECEF_Cen[0]=np.array(ECEF[i])
  ECEF_Der[0]=np.array(ECEF[i])
  ECEF_Izq[0]=np.array(ECEF[i])
  R_Cen=((ECEF_Cen[j][0])**2+(ECEF_Cen[j][1])**2+(ECEF_Cen[j][2])**2)**.5     # Distancia al Centro de la Tierra   

  Desv_Cen[iloc][0]=np.array(LLH[i])
  Desv_Der[iloc][0]=np.array(LLH[i])
  Desv_Izq[iloc][0]=np.array(LLH[i])

  Dir_GeoCenter_Cen=np.array(ECEF[j])/R_Cen
  Vel_ECEF[0]=ENUtoECEF.dot(np.array(VelENU[i]))

  Vel_ECEF_Cen[j]=Vel_ECEF[j]
  Vel_ECEF_Der[j]=Vel_ECEF[j]
  Vel_ECEF_Izq[j]=Vel_ECEF[j]
  
  ENU_Cen[0]=np.array(ENU[i])
  ENU_Der[0]=np.array(ENU[i])
  ENU_Izq[0]=np.array(ENU[i])

  R_Der=(ECEF_Der[j][0]**2+ECEF_Der[j][1]**2+ECEF_Der[j][2]**2)**.5     # Dstancia al Centro de la Tierra 
  R_Izq=(ECEF_Izq[j][0]**2+ECEF_Izq[j][1]**2+ECEF_Izq[j][1]**2)**.5     # Dstancia al Centro de la Tierra   

  Dir_GeoCenter_Der=np.array(ECEF[j])/R_Der
  Dir_GeoCenter_Izq=np.array(ECEF[j])/R_Izq

  if ilocmax<i:
    ECEF_Der.append(np.array([0,0,0]))
    ECEF_Izq.append(np.array([0,0,0]))

    Vel_ECEF.append(np.array([0,0,0]))
    Vel_ECEF_Der.append(np.array([0,0,0]))
    Vel_ECEF_Izq.append(np.array([0,0,0]))
    Desv_Cen.append([np.array([0,0,0])])
    Desv_Der.append([np.array([0,0,0])])
    Desv_Izq.append([np.array([0,0,0])])

    ENU_Cen.append(np.array([0,0,0]))
    ENU_Der.append(np.array([0,0,0]))
    ENU_Izq.append(np.array([0,0,0]))

    IP_Cen.append(np.array([0,0,0]))
    IP_Der.append(np.array([0,0,0]))
    IP_Izq.append(np.array([0,0,0]))


    ilocmax=i
    j=0
    jmax=0
  while Desv_Cen[iloc][j][2]>=0:

    if jmax<=j:
      Gravity_Cen.append(np.array([0,0,0]))
      Acc_ECEF_Cen.append(np.array([0,0,0]))
      Vel_ECEF_Cen.append(np.array([0,0,0]))
      Vel_ECEF_Cen.append(np.array([0,0,0]))

      ECEF_Cen.append(np.array([0,0,0]))
      ECEF_Cen.append(np.array([0,0,0]))

      Desv_Cen[iloc].append(np.array([0,0,0]))
      Desv_Cen[iloc].append(np.array([0,0,0]))
      ENU_Cen.append(np.array([0,0,0]))
      AER_Cen.append(np.array([0,0,0]))
      jIP.append(0)

      jmax=j

    # Calculo Dinamico dle Cohete
    #Gravedad en ECEF
    R_Cen=((ECEF_Cen[j][0])**2+(ECEF_Cen[j][1])**2+(ECEF_Cen[j][2])**2)**.5     # Distancia al Centro de la Tierra   
    Gravity_Cen[j]=np.transpose(-ECEF_Cen[j])*Mu*EarthMass/(R_Cen**3)  # Vector de Gravedad        
    # Vector accelaracion en ECEF
    Acc_ECEF_Cen[j]=Gravity_Cen[j] # + (Drag1[j]+Thrust1[j])/M_Rocket1[j] 
    # Vector velocidad en ECEF
    Vel_ECEF_Cen[j+1]=Vel_ECEF_Cen[j]+Acc_ECEF_Cen[j]*dt

    # Vector de posicion en coordenadas ENU, ENU

    ECEF_Cen[j+1]=ECEF_Cen[j]+Vel_ECEF_Cen[j]*dt

    #ECEF to Geocentric, se hara un calculo que requiere varias iteracion
    #por punto fijo. Pasar de ECEF a Gecentric no es exacta requeire varias
    #iteraciones, los valores con "g" estaran cambiando con cada iteracion    
    # El objetivo de esto era calcualr el cambio de las coordenaradas
    # geocetricas y ECEF apartir del movienito del cohete en las coordenadas
    # ENU por lo que guadamos el dato de las nuevas geocentricas
    Desv_Cen[iloc][j+1]= ECEFtoLLH(ECEF_Cen[j+1][0], ECEF_Cen[j+1][1], ECEF_Cen[j+1][2])
  
#    if iloc==100:
#      Tray_Cen[j]=Desv_Cen[iloc][j]

    
    # Azimuth-elevation-range AER from ENU #despues
    [Az_Cen, Range_Cen, Az2_Cen]=LLHtoAER(BaseLanzamiento[0]*pi/180, BaseLanzamiento[1]*pi/180, Desv_Cen[iloc][j][0], (Desv_Cen[iloc][j][1]))

    ENU_Cen[j]=ECEFtoENU@ECEF_Cen[j+1]
    AER_Cen[j+1]=[Az_Cen, math.atan2(ENU_Cen[j][2],(ENU_Cen[j][0]**2+ENU_Cen[j][1]**2)**.5) ,Range_Cen]

      
      # ECI
#         theta=omega*t(j)
#         ECEFtoECI=[ cos(theta) -sin(theta) 0
#                     sin(theta)  cos(theta) 0
#                             0           0  1]
#         ECI1(j+1,:)=ECEFtoECI*ECEF1(j,:)
      
      # Registrar la ultima ubicacion de la dinamica del cohete. Esto
      # para conocer el Immpacto Point IP
    jIP[iloc]=j
    j=j+1
  
  IP_Cen[iloc]=(Desv_Cen[iloc][jIP[iloc]])
  Rango=Range_Cen

#---------------------------------------------------------------------------------
# 
#----------------------------------------------------------------------------------

  j=0
  jmax=0
  Fr=1-(Rango/9300000)

  if Fr<0:
    Fr=0
  if Fr>1:
    Fr=1
  Yaw_Desv_Der=(pi/4)*Fr
  Yaw_Desv_Izq=-(pi/4)*Fr

  Vel_ECEF_Der[j]=Vel_ECEF[j]*math.cos(Yaw_Desv_Der) + np.cross(Dir_GeoCenter_Der,Vel_ECEF[j])*math.sin(Yaw_Desv_Der) + Dir_GeoCenter_Der*(Dir_GeoCenter_Der.dot(Vel_ECEF[j]))*(1-math.cos(Yaw_Desv_Der))
  Vel_ECEF_Izq[j]=Vel_ECEF[j]*math.cos(Yaw_Desv_Izq) + np.cross(Dir_GeoCenter_Izq,Vel_ECEF[j])*math.sin(Yaw_Desv_Izq) + Dir_GeoCenter_Izq*(Dir_GeoCenter_Izq.dot(Vel_ECEF[j]))*(1-math.cos(Yaw_Desv_Izq))

  while Desv_Der[iloc][j][2]>=0 or Desv_Izq[iloc][j][2] >=0:
      # Calculo Dinamico dle Cohete
      #Gravedad en ECEF
      if jmax<=j:
        Gravity_Der.append(np.array([0,0,0]))
        Gravity_Izq.append(np.array([0,0,0]))

        Acc_ECEF_Der.append(np.array([0,0,0]))
        Acc_ECEF_Izq.append(np.array([0,0,0]))

        Vel_ECEF_Der.append(np.array([0,0,0]))
        Vel_ECEF_Der.append(np.array([0,0,0]))
        Vel_ECEF_Izq.append(np.array([0,0,0]))
        Vel_ECEF_Izq.append(np.array([0,0,0]))

        ECEF_Der.append(np.array([0,0,0]))
        ECEF_Der.append(np.array([0,0,0]))
        ECEF_Izq.append(np.array([0,0,0]))
        ECEF_Izq.append(np.array([0,0,0]))

        Desv_Der[iloc].append(np.array([0,0,0]))
        Desv_Der[iloc].append(np.array([0,0,0]))
        Desv_Izq[iloc].append(np.array([0,0,0]))
        Desv_Izq[iloc].append(np.array([0,0,0]))

        ENU_Der.append(np.array([0,0,0]))
        ENU_Izq.append(np.array([0,0,0]))

        AER_Der.append(np.array([0,0,0]))
        AER_Der.append(np.array([0,0,0]))

        AER_Izq.append(np.array([0,0,0]))
        AER_Izq.append(np.array([0,0,0]))

        jIP.append(0)

        jmax=j

      R_Der=(ECEF_Der[j][0]**2+ECEF_Der[j][1]**2+ECEF_Der[j][2]**2)**.5     # Dstancia al Centro de la Tierra   
      R_Izq=(ECEF_Izq[j][0]**2+ECEF_Izq[j][1]**2+ECEF_Izq[j][2]**2)**.5     # Dstancia al Centro de la Tierra   

      Gravity_Der[j]=np.transpose(-ECEF_Der[j])*Mu*EarthMass/(R_Der**3)  # Vector de Gravedad   
      Gravity_Izq[j]=np.transpose(-ECEF_Izq[j])*Mu*EarthMass/(R_Izq**3)  # Vector de Gravedad        

      # Vector accelaracion en ECEF
      Acc_ECEF_Der[j]=Gravity_Der[j] # + (Drag1(j,:)+Thrust1(j,:))/M_Rocket1(j) 
      Acc_ECEF_Izq[j]=Gravity_Izq[j] # + (Drag1(j,:)+Thrust1(j,:))/M_Rocket1(j) 

      # Vector velocidad en ECEF
      Vel_ECEF_Der[j+1]=Vel_ECEF_Der[j]+Acc_ECEF_Der[j]*dt
      Vel_ECEF_Izq[j+1]=Vel_ECEF_Izq[j]+Acc_ECEF_Izq[j]*dt

      # Vector de posicion en coordenadas ENU, ENU
      ECEF_Der[j+1]=ECEF_Der[j]+Vel_ECEF_Der[j]*dt
      ECEF_Izq[j+1]=ECEF_Izq[j]+Vel_ECEF_Izq[j]*dt

      #ECEF to Geocentric, se hara un calculo que requiere varias iteracion
      #por punto fijo. Pasar de ECEF a Gecentric no es exacta requeire varias
      #iteraciones, los valores con "g" estaran cambiando con cada iteracion    
      # El objetivo de esto era calcualr el cambio de las coordenaradas
      # geocetricas y ECEF apartir del movienito del cohete en las coordenadas
      # ENU por lo que guadamos el dato de las nuevas geocentricas
      Desv_Der[iloc][j+1]= ECEFtoLLH(ECEF_Der[j+1][0], ECEF_Der[j+1][1], ECEF_Der[j+1][2])
      Desv_Izq[iloc][j+1]= ECEFtoLLH(ECEF_Izq[j+1][0], ECEF_Izq[j+1][1], ECEF_Izq[j+1][2])   
  
#      if iloc==100:
#          Tray_Der[j]=Desv_Der[iloc,j]
#          Tray_Izq[j]=Desv_Izq[iloc,j]

      

      # Azimuth-elevation-range AER from ENU
      [Az_Der, Range_Der, Az2_Der]=LLHtoAER(BaseLanzamiento[0]*pi/180, BaseLanzamiento[1]*pi/180, (Desv_Der[iloc][j][0]), (Desv_Der[iloc][j][1]))
      [Az_Izq, Range_Izq, Az2_Izq]=LLHtoAER(BaseLanzamiento[0]*pi/180, BaseLanzamiento[1]*pi/180, (Desv_Izq[iloc][j][0]), (Desv_Izq[iloc][j][1]))
  
      ENU_Der[j]=np.transpose(ECEFtoENU@ECEF_Der[j+1])
      ENU_Izq[j]=np.transpose(ECEFtoENU@ECEF_Izq[j+1])

      AER_Der[j+1]=[Az_Der, math.atan2(ENU_Der[j][2],(ENU_Der[j][0]**2+ENU_Der[j][1]**2)**.5),Range_Der]
      AER_Izq[j+1]=[Az_Izq, math.atan2(ENU_Izq[j][2],(ENU_Izq[j][0]**2+ENU_Izq[j][1]**2)**.5),Range_Izq]
      
        #ECI
#         theta=omega*t(j)
#         ECEFtoECI=[ cos(theta) -sin(theta) 0
#                     sin(theta)  cos(theta) 0
#                             0           0  1]
#         ECI1(j+1,:)=ECEFtoECI*ECEF1(j,:)
      
      # Registrar la ultima ubicacion de la dinamica del cohete. Esto
      # para conocer el Immpacto Point IP
      jIP[iloc]=j
      j=j+1
  
  IP_Der[iloc]=(Desv_Der[iloc][jIP[iloc]])
  IP_Izq[iloc]=(Desv_Izq[iloc][jIP[iloc]])
  #print(Rango, Desv_Cen[iloc][j][0], (Desv_Cen[iloc][j][1]), Desv_Der[iloc][j][0], Desv_Der[iloc][j][1],  Desv_Izq[iloc][j][0], Desv_Izq[iloc][j][1])

  i=i+1

IP_Der=np.multiply( np.array(IP_Der),180/pi)
IP_Izq=np.multiply( np.array(IP_Izq),180/pi)
IP_Cen=np.multiply(np.array(IP_Cen),180/pi)

LLH=np.array(LLH)
ZonaExclIzq=np.array(ZonaExclIzq)
ZonaExclDer=np.array(ZonaExclDer)

print(ZonaExclDer)
#primera gráfica
fig = go.Figure(go.Scattermapbox(
                            
                                  mode = "markers+lines",
                                  lat=IP_Der[1:-1,0],
                                  lon=IP_Der[1:-1,1],
                                  marker = {'size': 5}))

fig.add_trace(go.Scattermapbox(  
                                  mode = "markers+lines",
                                  lat= IP_Izq[1:-1,0],
                                  lon= IP_Izq[1:-1,1],
                                  marker = {'size': 5}))
fig.add_trace(go.Scattermapbox(  
                                  mode = "markers+lines",
                                  lat= IP_Cen[1:-1,0],
                                  lon= IP_Cen[1:-1,1],
                                  marker = {'size': 5}))
fig.add_trace(go.Scattermapbox(  
                                  mode = "markers+lines",
                                  lat= LLH[1:-1,0],
                                  lon= LLH[1:-1,1],
                                  marker = {'size': 5}))
fig.add_trace(go.Scattermapbox(  
                                  mode = "markers+lines",
                                  lat= ZonaExclDer[1:-1,0] * 180 / pi,
                                  lon= ZonaExclDer[1:-1,1] * 180 / pi,
                                  marker = {'size': 5}))
fig.add_trace(go.Scattermapbox(  
                                  mode = "markers+lines",
                                  lat= ZonaExclIzq[1:-1,0] * 180 / pi,
                                  lon= ZonaExclIzq[1:-1,1] * 180 / pi,
                                  marker = {'size': 5}))


 
fig.update_layout(
    margin ={'l':0,'t':0,'b':0,'r':0},
    mapbox = {
        'center': {'lon': 50, 'lat': 70},
        'style': "stamen-terrain",
        'center': {'lon': -40, 'lat': -20},
        'zoom': 0.05})
fig.show()

#segunda grafica de rango

fig = go.Figure(go.Scattermapbox(
                            
                                  mode = "markers+lines",
                                  lat= IP_Cen[1:-1,0],
                                  lon= IP_Cen[1:-1,1],
                                  marker = {'size': 5}))

#fig = go.Figure(data=go.Scattergeo(
#                                      lat=Tray_Der[:,0],
#                                      lon=Tray_Der[:,1],
#                                      mode='markers',
#                                     ))
#fig.add_trace(go.Scattergeo(
#                              lat= Tray_Izq[:,0],
#                              lon= Tray_Izq[:,1],
#                              mode='lines',
#                              ))

fig.update_layout(
    margin ={'l':0,'t':0,'b':0,'r':0},
    mapbox = {
        'center': {'lon': 50, 'lat': 70},
        'style': "stamen-terrain",
        'center': {'lon': -40, 'lat': -20},
        'zoom': 0.05})
fig.show()